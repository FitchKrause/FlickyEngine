<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10000</depth>
  <persistent>0</persistent>
  <parentName>par_controller</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Variables.
 // Camera system by: Noah Copeland and Aleks.

 // Screen Resolution:
    _W = global.ScreenWidth;
    _H = global.ScreenHeight;
    
 // Setup view:
    view_object  [0] = id;
    view_hborder [0] = _W/2;
    view_vborder [0] = _H/2;
    
    
 // Create rectangle around the subject that the subject must exceed before the camera will move.
    Cam_LeftBorder   = x-8;
    Cam_RightBorder  = x+8;
    Cam_TopBorder    = y-32;
    Cam_BottomBorder = y+32;
    
 // Additional Variables:
    Cam_Subject      = par_character; // - Who is the camera following? (Often the player)
    Cam_SubjectSpeed = 6;             // - Speed at wich to change target/subject.
    Cam_Lock         = false;         // - Whether the camera is locked from moving.
    
 // Limits, you can't go outside these boundaries.
    Cam_LeftLimit   = 0;
    Cam_RightLimit  = room_width;
    Cam_TopLimit    = 0;
    Cam_BottomLimit = room_height;
 
 // Binding/Lag variables.
    Cam_BindX = 0;
    Cam_BindY = 0;
    Cam_Lag   = 0;
    
 // Define Camera position. We use temp. variables called Cam_XX and Cam_YY to help with the shifting while looking up/down.
    Cam_XX = x;
    Cam_YY = y;
    
 // Shifting variables:
    Cam_ShiftX     = 0;
    Cam_ShiftY     = 0;
    Cam_ShiftSpeed = 2;
 
 // Special Functions.
    Cam_ShakeScreen   = false;
    Cam_ShakeDuration = 0;   
    Cam_ShakeForce    = 0;
    Cam_ShakeSound    = 0;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Shift/Pan the Camera.
 // This event should only run if we follow the character.
 
    if(Cam_Subject == par_character){
    
       // Shift up:
          if(Cam_Subject.Action == ActionLookup &amp;&amp; Cam_Subject.TimerUp &gt;= 120)
             Cam_ShiftY = max(-104, Cam_ShiftY-Cam_ShiftSpeed);
          else
       // Shift down:          
          if(Cam_Subject.Action == ActionCrouch &amp;&amp; Cam_Subject.TimerDown &gt;= 120)
             Cam_ShiftY = min(104, Cam_ShiftY+Cam_ShiftSpeed);
          else
             Cam_ShiftY = max(0, abs(Cam_ShiftY)-Cam_ShiftSpeed)*sign(Cam_ShiftY);
          
       
       // Pan the camera horizontally if the character is using the peelout:
          if((Cam_Subject.Action == ActionPeelout &amp;&amp; Cam_Subject.PeeloutTimer &gt; 6) || Cam_Subject.PeeloutFlag == 1){
             var PanDirection = sign(Cam_Subject.XSpeed + Cam_Subject.AnimationDirection);
                 Cam_ShiftX   = clamp((abs(Cam_ShiftX) + Cam_ShiftSpeed) * PanDirection, -64, 64);  
          }else{
                 Cam_ShiftX   = max(0, abs(Cam_ShiftX)-Cam_ShiftSpeed)sign(Cam_ShiftX);
          }
       
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Main Camera Control

//Update borders
Cam_LeftBorder   = Cam_XX-8;
Cam_RightBorder  = Cam_XX+8;
Cam_TopBorder    = Cam_YY-32;
Cam_BottomBorder = Cam_YY+32;


//set up some local variables to make for neat-looking code
var vw = (view_wview[0])/2;
var vh = (view_hview[0])/2;


//Move the Camera
if Cam_Subject = par_character
{
    //1. HORIZTONAL MOVEMENT
    //if Player has exceed the right border, move the camera by the amount exceeded
    if (Cam_Subject.x &gt; Cam_RightBorder &amp;&amp; Cam_Subject.x &lt;= Cam_RightLimit-vw)
    {
        Cam_XX += min(abs(Cam_Subject.x-Cam_RightBorder),16);
    }
    
    //if Player has exceed the left border, move the camera by the amount exceeded
    if (Cam_Subject.x &lt; Cam_LeftBorder &amp;&amp; Cam_Subject.x &gt;= Cam_LeftLimit+vw)
    {
        Cam_XX -= min(abs(Cam_LeftBorder-Cam_Subject.x),16);
    }
    
    //2. VERTICAL MOVEMENT
    //in the air....
    if (Cam_Subject.Ground == false &amp;&amp; Cam_Subject.Action != ActionDie)
    {
        //if Player has exceed the bottom border, move the camera by the amount exceeded
        if (Cam_Subject.y &gt; Cam_BottomBorder &amp;&amp; Cam_Subject.y &lt; Cam_BottomLimit-vh)
        {
            Cam_YY += Cam_Subject.y-Cam_BottomBorder;
        }
        
        //if Player has exceed the top border, move the camera by the amount exceeded
        if (Cam_Subject.y &lt; Cam_TopBorder &amp;&amp; Cam_Subject.y &gt; Cam_TopLimit+vh)
        {
            Cam_YY -= Cam_TopBorder-Cam_Subject.y;
        }
    }
    
    //on the ground
    if (Cam_Subject.Ground == true &amp;&amp; Cam_Subject.Action != ActionDie)
    {
        //if player is not centered vertically
        if Cam_Subject.y != Cam_YY
        {
            //this creates the camera lag when you land after a jump
            if abs(Cam_Subject.y-Cam_Subject.yprevious) &lt;= 6 //if sonic has only moved six of less pixels from the previous frame. The reason we use yprevious instead of YSpeed is because we have to account for slopes, in which Sonic technically moving vertically, despite his YSpeed being zero.
            {
                if (Cam_Subject.y &gt; Cam_YY &amp;&amp; Cam_Subject.y &lt; Cam_BottomLimit-vh)
                Cam_YY += min(abs(Cam_Subject.y-Cam_YY),6);
                
                
                if (Cam_Subject.y &lt; Cam_YY &amp;&amp;  Cam_Subject.y &gt; Cam_TopLimit+vh)
                Cam_YY -= min(abs(Cam_YY-Cam_Subject.y),6);
            }
            
            //this keeps thing mostly centered when going on loops and slopes, though there is a limit... 
            //...if Sonic is moving vertically faster than 16 px, he will "outrun" the camera. this is denoted by the min function
            if abs(Cam_Subject.y-Cam_Subject.yprevious) &gt; 6
            {
                if (Cam_Subject.y &gt; Cam_YY &amp;&amp; Cam_Subject.y &lt; Cam_BottomLimit-vh)
                Cam_YY += min(abs(Cam_Subject.y-Cam_YY),16);
                
                
                if (Cam_Subject.y &lt; Cam_YY &amp;&amp;  Cam_Subject.y &gt; Cam_TopLimit+vh)
                Cam_YY -= min(abs(Cam_YY-Cam_Subject.y),16);
            }
        }
    }

}







//Otherwise, if the camera is not looking at the player, but at an NPC or something ( like a boss fight)
if (Cam_Subject != noone &amp;&amp; Cam_Subject != par_character)
{
//if target is not centered horizontally
if Cam_Subject.x != Cam_XX
{

if (Cam_Subject.x &gt; Cam_XX &amp;&amp;  Cam_XX &lt;= Cam_RightLimit-vw)
    Cam_XX += min(abs(Cam_Subject.x-Cam_XX),6);


if (Cam_Subject.x &lt; Cam_XX &amp;&amp;  Cam_XX &gt;= Cam_LeftLimit+vw)
    Cam_XX -= min(abs(Cam_XX-Cam_Subject.x),6);
}



//if target is not centered vertically
if Cam_Subject.y != Cam_YY
{

if (Cam_Subject.y &gt; Cam_YY &amp;&amp; Cam_YY &lt; Cam_BottomLimit-vh)
    Cam_YY += min(abs(Cam_Subject.y-Cam_YY),6);


if (Cam_Subject.y &lt; Cam_YY &amp;&amp;  Cam_YY &gt; Cam_TopLimit+vh)
    Cam_YY -= min(abs(Cam_YY-Cam_Subject.y),6);
}


}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update position.
    x = Cam_XX + Cam_ShiftX;
    y = Cam_YY + Cam_ShiftY;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
