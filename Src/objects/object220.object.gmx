<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10000</depth>
  <persistent>0</persistent>
  <parentName>par_controller</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Camera Variables.
  
       win_x = display_get_width()/2
       win_y = display_get_height()/2
       
    // Define Borders:
       TopBorder    =  64;
       BottomBorder = 128;
       LeftBorder   = 152;
       RightBorder  = 168;
       ActBorder    = 0;
       
    // Define View variables:       
       ViewLeft   = 0;
       ViewRight  = 0;
       ViewTop    = 0;
       ViewBottom = 0;    
       
    // Define Camera Position
       Camera_X = x;
       Camera_Y = y;

       
    // Define min/max positions when we bind the camera:
       Camera_BindX = false;
       Camera_BindY = false;       
       Camera_MaxX  = 0;
       Camera_MinX  = 0;
       Camera_MaxY  = 0;
       Camera_MinY  = 0;
                  
    // Set Camera Target:
       Camera_Target = par_character;

    // Set the Camera (Movement) Type:
       Camera_Type   = "DEFAULT";
          
    // Shifting variables:
       Camera_Shift_X       = 0; // Camera Shift X Value.
       Camera_Shift_Y       = 0; // Camera Shift Y Value.
       Camera_Shift_Speed   = 2;
       
    // Special functions.
       Camera_Lag = 0                             // Used to lag the Camera.    
       Camera_ShakeScreen   = false;              // If enabled, the screen will shake as long as _ShakeDuration is above 0.
       Camera_ShakeDuration = 0;                  // How many frames the Shaking lasts.
       Camera_ShakeForce    = 0;                  // The force of the Shake, 2 to 3 is a good number, everything above 3 is a strong shake.
       Camera_ShakeSound    = snd_object_crumble; // If not set to noone, the game will loop this sound until the shake is over.
       Camera_DebugDisplay  = false;              // Displays Debug Graphics.         
       
       
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Shift the Camera Up or Down.

    // Only run this if we follow the Character:
       if(Camera_Target == par_character){
       
          // Looking up:
          if(Camera_Target.Action == ActionLookup &amp;&amp; Camera_Target.TimerUp &gt;= 120)        
              Camera_Shift_Y = max(-104, Camera_Shift_Y-2);
          // Looking Down:
          else if(Camera_Target.Action == ActionCrouch &amp;&amp; Camera_Target.TimerDown &gt;= 120)       
              Camera_Shift_Y = min(104, Camera_Shift_Y+2);                  
          else
              Camera_Shift_Y = max(0, abs(Camera_Shift_Y)-2)*sign(Camera_Shift_Y);      

          // Pan the camera horizintally if the character is using a peelout move.
             if((Camera_Target.Action == ActionPeelout &amp;&amp; Camera_Target.PeeloutTimer &gt; 6) || Camera_Target.PeeloutFlag == 1){
                var _dir = sign(Camera_Target.XSpeed + Camera_Target.AnimationDirection);
                Camera_Shift_X = clamp((abs(Camera_Shift_X) + Camera_Shift_Speed) * _dir, -64, 64);
             }else{
                Camera_Shift_X = max(0, abs(Camera_Shift_X)-2)*sign(Camera_Shift_X); 
             }
             
        }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle the Cameras movement.

    // Character Camera:
    // -----------------------------------------------------------------------------------------------------------------------------------
    
       if(Camera_Target == par_character &amp;&amp; Camera_Type == "DEFAULT"){
         
          // Only run this if the target is not death:
             if(Camera_Target.Action != ActionDie){
                       
          // Update the view variables:    
             ViewTop    = view_yview + TopBorder    - Camera_Shift_Y;
             ViewBottom = view_yview + BottomBorder - Camera_Shift_Y;  
             ViewLeft   = view_xview + LeftBorder   - Camera_Shift_X;
             ViewRight  = view_xview + RightBorder  - Camera_Shift_X;

          // Check if we exceed the Borders:

               if(Camera_Target.x &gt; ViewRight+Camera_Lag){
                  x += floor(Camera_Target.x - ViewRight-Camera_Lag);
               }
               if(Camera_Target.x &lt; ViewLeft-Camera_Lag){
                  x -= floor(ViewLeft-Camera_Lag - Camera_Target.x);          
               }
               if(Camera_Target.y &lt; ViewTop){                    
                  y -= floor(ViewTop - Camera_Target.y);
               }                            
               if(Camera_Target.y &gt; ViewBottom){
                  y += floor(Camera_Target.y - ViewBottom);                       
               }       
         
                        
          // Limit the Cameras X/Y Position:
             if(Camera_BindX == false){
                if(x &gt;= floor(room_width - RightBorder)){
                   x  = floor(room_width - RightBorder);
                }
                if(x &lt;= floor(LeftBorder)){
                   x  = floor(LeftBorder);
                }  
             }else{
               if(x &gt;= floor(Camera_MaxX - RightBorder)){
                  x  = floor(Camera_MaxX - RightBorder);
               }
               if(x &lt;= floor(Camera_MinX + LeftBorder)){
                  x  = floor(Camera_MinX + LeftBorder);
               }                                              
             }            
             
          // Act Border:
             if(ActBorder != 0){
                if(x &lt;= floor(ActBorder + LeftBorder)){
                   x  = floor(ActBorder + LeftBorder);
                }
             }    
             
             if(Camera_BindY == false){                                
                if(y &gt;= floor(room_height - BottomBorder)){
                   y  = floor(room_height - BottomBorder);
                }
                if(y &lt;= floor(TopBorder)){
                   y  = floor(TopBorder);
                }   
             }else{
                if(y &gt;= floor(Camera_MaxY - BottomBorder)){
                   y  = floor(Camera_MaxY - BottomBorder);
                }
                if(y &lt;= floor(Camera_MinY + TopBorder)){
                   y  = floor(Camera_MinY + TopBorder);
                }                
             }           

             }
                        
          // Set the Camera X/Y Position: 
             if(Camera_ShakeScreen == false){       
                Camera_X = x + Camera_Shift_X;
                Camera_Y = y + Camera_Shift_Y;
             }else{
                Camera_X = x + Camera_Shift_X + random_range(-Camera_ShakeForce, Camera_ShakeForce)
                Camera_Y = y + Camera_Shift_Y + random_range(-Camera_ShakeForce, Camera_ShakeForce)                
             }
                        
          // Set the View:
             view_xview = clamp(Camera_X - (view_wview / 2), 0,  room_width - view_wview);
             view_yview = clamp(Camera_Y - (view_hview / 2), 0, room_height - view_hview);   

       }
                      
    // -----------------------------------------------------------------------------------------------------------------------------------       

    // Object Camera:
    // -----------------------------------------------------------------------------------------------------------------------------------
    
       if(Camera_Target != noone){
         
          // Follow an Instance:
             if(Camera_Type == "FOLLOW"){

                if(point_distance(x, y, Camera_Target.x, Camera_Target.y) &gt; 6){
                   move_towards_point(Camera_Target.x, Camera_Target.y, 6)
                   Camera_X = x;
                   Camera_Y = y;                   
                }else{
                   if(speed != 0){
                      speed  = 0;
                   }                
                   x = floor(Camera_Target.x);
                   y = floor(Camera_Target.y);
                   Camera_X = floor(Camera_Target.x);
                   Camera_Y = floor(Camera_Target.y);
                   if(Camera_Target == par_character){
                      Camera_Type    = "DEFAULT";
                   }                
                }

                   
                                                                  
             // Set the View:
                view_xview = clamp(Camera_X - (view_wview / 2), 0,  room_width - view_wview);
                view_yview = clamp(Camera_Y - (view_hview / 2), 0, room_height - view_hview);   
                               
             }

       }
                      
    // -----------------------------------------------------------------------------------------------------------------------------------       
    
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Camera Shake.
    if(Camera_ShakeScreen == true){
       if(Camera_ShakeDuration != 0){
          Camera_ShakeDuration--;
          if(Camera_ShakeSound != noone){
             if(CheckSound(Camera_ShakeSound) == false){
                LoopSound(Camera_ShakeSound, global.SFXVolume, 1);
             }
          }
       }else{
          Camera_ShakeScreen = false;
          if(Camera_ShakeSound != noone){
             if(CheckSound(Camera_ShakeSound) == true){
                StopSound(Camera_ShakeSound);
             }             
          }
       }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Camera lag timer.
    if(Camera_Lag &gt; 0){
       Camera_Lag -= 4;
    }else{
       Camera_Lag = 0;
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Camera Borders.
    
    //if(Camera_DebugDisplay){
    if(debug_mode){    
        draw_set_color(c_aqua);
    
        var top     = floor(view_yview +  TopBorder    -  Camera_Shift_Y);
        var bottom  = floor(view_yview +  BottomBorder -  Camera_Shift_Y);
        var center  = floor(view_yview + (TopBorder    + (BottomBorder-TopBorder)/2) - Camera_Shift_Y);
        var left    = floor(view_xview +  LeftBorder   -  Camera_Shift_X);
        var right   = floor(view_xview +  RightBorder  -  Camera_Shift_X);
        
        // Border
        draw_rectangle(left, top, right, bottom, true);

        // Center
        draw_set_color(c_lime);
        draw_line(left,  center,
                  right, center);        
                      
        if(Camera_Target != noone){
            draw_set_color(c_green);
            draw_circle(Camera_Target.x + Camera_Shift_X, Camera_Target.y + Camera_Shift_Y, 3, false);   
            draw_set_color(c_black);
            draw_circle(Camera_Target.x + Camera_Shift_X, Camera_Target.y + Camera_Shift_Y, 3, true);   
        
            draw_set_color(c_fuchsia);
            draw_circle(Camera_Target.x, Camera_Target.y, 3, false);   
            draw_set_color(c_black);
            draw_circle(Camera_Target.x, Camera_Target.y, 3, true);     
        }                   
        draw_set_color(c_white);
    }

    if(Camera_BindX){
       draw_set_color(c_red)
            draw_line(Camera_MinX+5, 0, Camera_MinX+5, room_height)
            draw_line(Camera_MaxX-5, 0, Camera_MaxX-5, room_height)      
            draw_line(0,Camera_MinY,room_width,Camera_MinY);                  
       draw_set_color(c_white)
    }

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
